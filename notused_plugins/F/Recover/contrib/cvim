#!/usr/bin/env python
# -%- coding: utf-8 -%-
# Author: Marcin Szamotulski
# Python Versions: 2.7, 3.4
# License: VIM LICENSE.
#          NO WARRANTY, EXPRESS OR IMPLIED> USE AT-YOUR-OWN-RISK.

import os
import sys
import subprocess
from glob import glob
import fnmatch
import argparse
import locale
import psutil
from operator import attrgetter
import six
if not six.PY3:
    input = raw_input
encoding = locale.getpreferredencoding()

NO_SWAP = object()

def check(swap):
    """
    check if swap file is used by a process
    """

    for process in psutil.get_process_list():
        try:
            files = process.get_open_files()
        except  psutil.AccessDenied:
            files = []
        files = map(attrgetter('path'), files)
        if swap in files:
            return process

if __name__ == '__main__':

    parser=argparse.ArgumentParser()
    parser.add_argument(
        dest='directory',
        nargs='*',
        default=(os.curdir,),
        help='directory where to look for swap (by default current directory)',
    )
    parser.add_argument(
        '-r', '-R', '--recursive',
        dest='recursive',
        action='store_true',
        help='search directory recursively'
    )
    parser.add_argument(
        '-f', '--find',
        dest='find',
        action='store_true',
        help='only find swap files, it impiles -r',
    )
    parser.add_argument(
        '-a', '--ask',
        dest='ask',
        action='store_true',
        help='ask before deleting swap files which do not '
             'differ from the file content.',
    )
    args = parser.parse_args(sys.argv[1:])

    if args.find:
        args.recursive=True

    curdir = os.path.normpath(os.path.abspath(os.curdir))
    swaps = []
    for dir_ in args.directories:
        if args.recursive:
            os.chdir(os.path.abspath(dir_))
            for dirp, dirs, fns in os.walk(os.curdir):
                if six.PY3:
                    swaps += map(lambda p:
                                 os.path.normpath(
                                     os.path.abspath(os.path.join(dirp, p))
                                     ),
                                 fnmatch.filter(fns, '.*.sw[a-z]'))
                else:
                    swaps += map(lambda p:
                                 os.path.normpath(
                                     os.path.abspath(os.path.join(dirp, p))
                                     ).decode(encoding),
                                 fnmatch.filter(fns, '.*.sw[a-z]'))
        else:
            os.chdir(os.path.abspath(dir_))
            pattern = '.*.sw[a-z]'
            swaps += glob(pattern)
    os.chdir(curdir)

    if len(swaps) == 0:
        print(u'No swap files found.')
        sys.exit(os.EX_OK)
    elif len(swaps) == 1:
        print(u'Found: {} swap file:'.format(len(swaps)))
    else:
        print(u'Found: {} swap files:'.format(len(swaps)))
    for swap in swaps:
        if swap.startswith(curdir):
            swap = u"{}{}".format(os.curdir, swap[len(curdir):])
        if six.PY3:
            print('  {}'.format(swap))
        else:
            print('  {}'.format(swap.encode(encoding)))
    if args.find:
        sys.exit(os.EX_OK)

    for swap in swaps:
        dir_, swp = os.path.split(swap)
        fname = swp[1:-4]
        path=os.path.join(dir_, fname)
        if six.PY3:
            _swap = swap
            _path = path
        else:
            _swap = swap.encode(encoding)
            _path = path.encode(encoding)

        import pdb
        pdb.set_trace()

        process = check(os.path.abspath(swap))
        if process:
            if process.terminal:
                terminal = " on %s" % process.terminal
            else:
                terminal = ""

            print('The "{}" swap file is used by process {} ({}){}.  '
                  'Skipping.'.format(_swap, str(process.pid),
                                     process.name,
                                     terminal))
            continue
        recovered = u'{}_'.format(swap)
        if os.path.exists(recovered):
            recovered = u'{}__'.format(swap)
            if os.path.exists(recovered):
                print('Skipping "{0}": the temporary file exists, please '
                      'check and delete "{0}_" and "{0}__"'.format(_swap))

                continue
        cmd = u'vim -X -u NONE -r +"w {0}|q" "{1}"'.format(recovered, swap)
        exit = subprocess.call(cmd, shell=True)
        if exit != os.EX_OK:
            print(u'Skipping {}: vim exited with error code {}'.format(_swap, exit))
            continue
        try:
            with open(recovered) as fo:
                swap_content = fo.read()
        except Exception as e:
            swap_content = NO_SWAP
        finally:
            os.remove(recovered)

        if os.path.exists(path):
            try:
                with open(path) as fo:
                    file_content = fo.read()
            except Exception:
                file_content = None
        else:
            file_content = None

        if file_content == swap_content:
            if args.ask:
                inp = input('The swap file "{}" and "{}" do not differ.'
                            '  Do you want to delete it?  [Y/N]\n'.
                            format(_swap, _path)
                            )
                inp = inp.lower()
                if inp == 'y' or inp == 'yes':
                    os.remove(swap)
            else:
                print(u'Deleting "{}" swap file (matching the content)'.
                      format(_swap))
                os.remove(swap)
        else:
            cmd = u'vim "{}"'.format(_path)
            vim = subprocess.Popen(cmd,
                                   shell=True)
            if vim.wait() != 0:
                sys.exit(vim.returncode)

    sys.exit(os.EX_OK)
