scriptencoding utf-8
let s:save_cpo = &cpo
set cpo&vim


function! s:_vital_loaded(V)
	let s:V = a:V
	let s:L = s:V.import("Data.List")
endfunction


function! s:_vital_depends()
	return ["Data.List"]
endfunction


let s:base = {
\	"variables" : {
\		"slots" : [],
\		"counter" : 0,
\	}
\}


function! s:base.connect(slot)
	let self.variables.counter += 1
	let slot = { "id" : self.variables.counter, "slot" : a:slot }
	call add(self.variables.slots, slot)
	return slot
endfunction


function! s:base.disconnect(slot)
	if empty(a:slot)
		return -1
	endif
	for i in range(len(self.variables.slots))
		if self.variables.slots[i].id == a:slot.id
			unlet self.variables.slots[i]
			return
		endif
	endfor
	return -1
endfunction


function! s:base.disconnect_by(expr)
	return self.disconnect(self.find_first_by(a:expr))
endfunction


function! s:call(list, func, ...)
	let args = get(a:, 1, [])
	let def = get(a:, 2, 0)
	return map(copy(a:list), "has_key(v:val, a:func) ? call(v:val.".a:func.", args, v:val) : def")
endfunction

function! s:base.call(func, ...)
	return call("s:call", [self.slots(), a:func] + a:000)
endfunction


function! s:base.find_by(expr)
	return filter(copy(self.variables.slots), a:expr)
endfunction


function! s:base.find_first_by(expr)
	return get(self.find_by(a:expr), 0, {})
endfunction


function! s:base.sort_by(expr)
	let self.variables.slots = s:L.sort_by(self.variables.slots, a:expr)
endfunction


function! s:base.get_slot(val)
	return a:val.slot
endfunction


function! s:base.slots()
	return map(copy(self.variables.slots), "self.get_slot(v:val)")
endfunction


" function! s:base.dict()
" 	let result = {}
" 	for _ in self.variables.slots
" 		let result[_.id] = _.value
" 	endfor
" 	return result
" endfunction


function! s:make()
	let result = deepcopy(s:base)
	return result
endfunction


let &cpo = s:save_cpo
unlet s:save_cpo
" ___Revitalizer___
" NOTE: below code is generated by :Revitalize.
" Do not mofidify the code nor append new lines
if v:version > 703 || v:version == 703 && has('patch1170')
  function! s:___revitalizer_function___(fstr) abort
    return function(a:fstr)
  endfunction
else
  function! s:___revitalizer_SID() abort
    return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze____revitalizer_SID$')
  endfunction
  let s:___revitalizer_sid = '<SNR>' . s:___revitalizer_SID() . '_'
  function! s:___revitalizer_function___(fstr) abort
    return function(substitute(a:fstr, 's:', s:___revitalizer_sid, 'g'))
  endfunction
endif

let s:___revitalizer_functions___ = {'_vital_depends': s:___revitalizer_function___('s:_vital_depends'),'_vital_loaded': s:___revitalizer_function___('s:_vital_loaded'),'call': s:___revitalizer_function___('s:call'),'make': s:___revitalizer_function___('s:make')}

unlet! s:___revitalizer_sid
delfunction s:___revitalizer_function___

function! vital#_easymotion#Over#Signals#import() abort
  return s:___revitalizer_functions___
endfunction
" ___Revitalizer___
