Include: include/setup.vader

Execute (Output is only processed in normal/insert mode (loclist)):
  if NeomakeAsyncTestsSetup()
    new
    lgetexpr 'init'
    file file_sleep_efm
    call neomake#Make(1, [g:sleep_efm_maker])
    norm! V
    NeomakeTestsWaitForFinishedJobs
    AssertEqual map(copy(getloclist(0)), 'v:val.text'), ['init'], 'Location list has not been updated'
    " with Vim
    " AssertNeomakeMessage 'exit (delayed): sleep_efm_maker: 0'
    AssertNeomakeMessage 'Not processing output for mode "V".'
    AssertNeomakeMessage 'sleep_efm_maker: completed with exit code 0.'
    AssertEqual mode(), 'V'
    exe "norm! \<Esc>"
    AssertEqual mode(), 'n'
    AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual len(g:neomake_test_finished), 0
    Assert exists('#neomake_process_pending#CursorHold'), 'neomake_process_pending augroup exists'
    doautocmd CursorHold
    sleep 100m
    Assert !exists('#neomake_process_pending#CursorHold'), 'neomake_process_pending is empty'
    AssertEqual len(g:neomake_test_countschanged), 1
    AssertEqual len(g:neomake_test_finished), 1, "b"
    AssertNeomakeMessage 'sleep_efm_maker: processing 3 lines of output.'
    AssertEqual map(getloclist(0), 'v:val.text'), ['error message', 'warning', 'error2']
    bwipe
  endif

Execute (Output is only processed in normal/insert mode (qflist)):
  if NeomakeAsyncTestsSetup()
    new
    file file_sleep_efm
    call neomake#Make(0, [g:sleep_efm_maker])[0]
    let jobinfo = neomake#GetJobs()[-1]
    norm! V
    NeomakeTestsWaitForFinishedJobs
    AssertEqual getqflist(), [], 'Quickfix list has not been updated'
    AssertNeomakeMessage 'sleep_efm_maker: completed with exit code 0.'
    AssertEqual mode(), 'V'
    exe "norm! \<Esc>"
    AssertEqual mode(), 'n'
    doautocmd CursorHold
    AssertNeomakeMessage 'sleep_efm_maker: processing 3 lines of output.'
    AssertNeomakeMessage 'Processed pending output.', 3, jobinfo
    AssertEqual map(getqflist(), 'v:val.text'), ['error message', 'warning', 'error2']
    NeomakeTestsWaitForRemovedJobs
    call neomake#signs#ResetProject()
    call neomake#signs#CleanAllOldSigns('project')
    bwipe
  endif

Execute (Location list is only cleared in normal/insert mode on success):
  if NeomakeAsyncTestsSetup()
    new
    lgetexpr 'init'
    file file_sleep_efm
    let maker = NeomakeTestsCommandMaker('silent-sleep-success', 'sleep .01')
    call neomake#Make(1, [maker])
    norm! V
    NeomakeTestsWaitForFinishedJobs
    AssertEqual map(getloclist(0), 'v:val.text'), ['init'], 'Location list has not been updated'

    AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual len(g:neomake_test_jobfinished), 1
    AssertEqual len(g:neomake_test_finished), 0

    AssertNeomakeMessage 'Cleaning jobinfo.', 3
    AssertNeomakeMessage 'File-level errors cleaned.', 3
    AssertNeomakeMessage 'Postponing final location list handling for mode "V".'
    AssertNeomakeMessage 'Queueing action: s:handle_locqf_list_for_finished_jobs for Timer.'

    AssertEqual mode(), 'V'
    exe "norm! \<Esc>"
    AssertEqual mode(), 'n'
    AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual len(g:neomake_test_finished), 0
    doautocmd WinEnter
    AssertEqual len(g:neomake_test_finished), 0
    AssertNeomakeMessage 'Retrying Timer event in 10ms.'
    sleep 10m
    AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual len(g:neomake_test_finished), 1
    AssertNeomakeMessage 'Cleaning location list.', 3
    AssertEqual map(getloclist(0), 'v:val.text'), []
    bwipe
  endif

Execute (Location list is not cleared in operator-pending mode (Vim)):
  if has('nvim')
    NeomakeTestsSkip 'only for Vim'
  elseif NeomakeAsyncTestsSetup()
    new
    lgetexpr 'init'
    file file_sleep_efm
    let maker = NeomakeTestsCommandMaker('silent-sleep-success', 'sleep .01')
    call neomake#Make(1, [maker])

    " Trigger operator-pending mode ('no').
    let b:cb_called = 0
    function! s:callback_in_operator_pending_mode(...)
      let b:cb_called = mode(1)
      call feedkeys("\<Esc>")
    endfunction
    call timer_start(100, 's:callback_in_operator_pending_mode')
    call feedkeys('da', 'x!')

    NeomakeTestsWaitForFinishedJobs
    AssertEqual map(getloclist(0), 'v:val.text'), ['init'], 'Location list has not been updated'

    AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual len(g:neomake_test_jobfinished), 1
    AssertEqual len(g:neomake_test_finished), 0

    AssertNeomakeMessage 'Cleaning jobinfo.', 3
    AssertNeomakeMessage 'File-level errors cleaned.', 3
    AssertNeomakeMessage 'Postponing final location list handling for mode "no".'
    AssertEqual b:cb_called, 'no'
    AssertNeomakeMessage 'Queueing action: s:handle_locqf_list_for_finished_jobs for Timer.'

    AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual len(g:neomake_test_finished), 0
    doautocmd WinEnter
    AssertEqual len(g:neomake_test_finished), 0
    AssertNeomakeMessage 'Retrying Timer event in 10ms.'
    sleep 10m
    AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual len(g:neomake_test_finished), 1
    AssertNeomakeMessage 'Cleaning location list.', 3
    AssertEqual map(getloclist(0), 'v:val.text'), []
    bwipe
  endif

Execute (Location list is only cleared in same window on success):
  if NeomakeAsyncTestsSetup()
    new
    let win = winnr()
    lgetexpr 'init'
    file file_sleep_efm
    let maker = NeomakeTestsCommandMaker('silent-sleep-success', 'sleep .01')
    call neomake#Make(1, [maker])
    new
    let win2 = winnr()
    lgetexpr 'init2'
    NeomakeTestsWaitForFinishedJobs
    AssertEqual map(getloclist(win), 'v:val.text'), ['init'], 'Location list has not been updated'
    AssertEqual map(getloclist(win2), 'v:val.text'), ['init2'], 'Location list has not been updated'
    AssertNeomakeMessage 'Cleaning jobinfo.', 3
    AssertNeomakeMessage 'Postponing final location list handling (in another window).'
    AssertNeomakeMessage 'Queueing action: s:handle_locqf_list_for_finished_jobs for WinEnter.'
    AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual len(g:neomake_test_finished), 0

    wincmd p
    AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual len(g:neomake_test_finished), 1
    AssertNeomakeMessage 'Cleaning location list.', 3
    AssertEqual map(getloclist(0), 'v:val.text'), []
    AssertEqual map(getloclist(win2), 'v:val.text'), ['init2'], 'Location list has not been updated'
    wincmd p
    bwipe
    bwipe
  endif

Execute (Output is only processed in normal/insert mode (from loclist)):
  if NeomakeAsyncTestsSetup()
    new
    call neomake#Make(1, [g:sleep_efm_maker])
    lopen
    AssertEqual &buftype, 'quickfix'
    AssertEqual winnr(), 3
    AssertEqual line('$'), 1
    norm! V
    NeomakeTestsWaitForFinishedJobs
    AssertEqual getloclist(0), [], 'Location list has not been updated'
    AssertNeomakeMessage 'sleep_efm_maker: completed with exit code 0.'
    AssertEqual mode(), 'V'
    exe "norm! \<Esc>"
    AssertEqual mode(), 'n'
    doautocmd CursorHold
    AssertEqual getloclist(0), []
    wincmd p
    AssertNeomakeMessage 'sleep_efm_maker: processing 3 lines of output.'
    AssertEqual map(getloclist(0), 'v:val.text'), ['error message', 'warning', 'error2']

    " NOTE: needs cache busting above ("bust_cache").
    let ll_bufnr = bufnr('file_sleep_efm')
    AssertEqual map(getloclist(0), 'v:val.bufnr'), [ll_bufnr, ll_bufnr, ll_bufnr]
    lclose
    bwipe
    bwipe file_sleep_efm
  endif

Execute (Output gets not processed while in loclist):
  if NeomakeAsyncTestsSetup()
    new
    file file_sleep_efm
    call neomake#Make(1, [g:sleep_efm_maker])
    lopen
    AssertEqual &buftype, 'quickfix'
    AssertEqual winnr(), 3
    NeomakeTestsWaitForFinishedJobs
    AssertEqual winnr(), 3

    AssertEqual len(g:neomake_test_finished), 0
    AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual getloclist(0), []

    lclose
    AssertEqual len(g:neomake_test_finished), 1
    AssertEqual len(g:neomake_test_countschanged), 1
    AssertEqual map(getloclist(0), 'v:val.text'), ['error message', 'warning', 'error2']
    bwipe
  endif

Execute (Unbuffered output handled correctly (loclist)):
  if NeomakeAsyncTestsSetup()
    " Produce intersected output: 1_1, 2_1, 1_2, 2_2, …
    let s:tmpfile1 = tempname()
    let s:tmpfile2 = tempname()
    call writefile([], s:tmpfile2)
    let maker_1 = extend(neomake#utils#MakerFromCommand(
      \ 'for i in $(seq 1 3); do while [ -e '.s:tmpfile1.' ]; do sleep 0.001; done; echo 1_$i; touch '.s:tmpfile1.'; done'), {
      \ 'name': 'maker1', 'buffer_output': 0, 'errorformat': '%m', 'append_file': 0})
    let maker_2 = extend(neomake#utils#MakerFromCommand(
      \ 'for i in $(seq 1 3); do while [ -e '.s:tmpfile2.' ]; do sleep 0.001; done; echo 2_$i; touch '.s:tmpfile2.'; done'), {
      \ 'name': 'maker2', 'buffer_output': 0, 'errorformat': '%m', 'append_file': 0})

    function! s:process_output(context)
      if a:context.jobinfo.maker.name ==# 'maker1'
        call delete(s:tmpfile2)
      else
        call delete(s:tmpfile1)
      endif
      return [{'text': join(a:context.output), 'lnum': 1}]
    endfunction
    let maker_1.process_output = function('s:process_output')
    let maker_2.process_output = function('s:process_output')


    let [jobinfo1, jobinfo2] = neomake#Make({'enabled_makers': [maker_1, maker_2]})
    Assert jobinfo1.id < jobinfo2.id, "jobinfo1 before jobinfo2"
    NeomakeTestsWaitForRemovedJobs
    AssertEqual len(g:neomake_test_countschanged), 6
    AssertEqual map(getloclist(0), 'v:val.text'),
      \ ['1_1', '2_1', '1_2', '2_2', '1_3', '2_3']
  endif

Execute (Unbuffered output handled correctly (qflist)):
  if NeomakeAsyncTestsSetup()
    " Produce intersected output: 1_1, 2_1, 1_2, 2_2, …
    let s:tmpfile1 = tempname()
    let s:tmpfile2 = tempname()
    call writefile([], s:tmpfile2)
    let maker_1 = extend(neomake#utils#MakerFromCommand(
      \ 'for i in $(seq 1 3); do while [ -e '.s:tmpfile1.' ]; do sleep 0.001; done; echo 1_$i; touch '.s:tmpfile1.'; done'), {
      \ 'name': 'maker1', 'buffer_output': 0, 'errorformat': '%m', 'append_file': 0})
    let maker_2 = extend(neomake#utils#MakerFromCommand(
      \ 'for i in $(seq 1 3); do while [ -e '.s:tmpfile2.' ]; do sleep 0.001; done; echo 2_$i; touch '.s:tmpfile2.'; done'), {
      \ 'name': 'maker2', 'buffer_output': 0, 'errorformat': '%m', 'append_file': 0})

    function! s:process_output(context)
      if a:context.jobinfo.maker.name ==# 'maker1'
        call delete(s:tmpfile2)
      else
        call delete(s:tmpfile1)
      endif
      return [{'text': join(a:context.output), 'lnum': 1}]
    endfunction
    let maker_1.process_output = function('s:process_output')
    let maker_2.process_output = function('s:process_output')


    let [jobinfo1, jobinfo2] = neomake#Make({'file_mode': 0, 'enabled_makers': [maker_1, maker_2]})
    Assert jobinfo1.id < jobinfo2.id, "jobinfo1 before jobinfo2"
    NeomakeTestsWaitForRemovedJobs
    AssertEqual len(g:neomake_test_countschanged), 6
    AssertEqual map(getqflist(), 'v:val.text'),
      \ ['1_1', '2_1', '1_2', '2_2', '1_3', '2_3']
  endif

Execute (Sleep in postprocess gets handled correctly):
  " This tests the workarounds for issues with both Vim and Neovim.
  " https://github.com/vim/vim/issues/1320
  " https://github.com/neovim/neovim/issues/5889
  " Reproduces flakiness with https://github.com/neomake/neomake/issues/899.
  call neomake#statusline#ResetCounts()
  if NeomakeAsyncTestsSetup()
    let s:postprocess_count = 0
    function! s:postprocess(entry) dict
      let s:postprocess_count += 1
      if s:postprocess_count == 1
        exe 'sleep 300m'
      endif
    endfunction

    let maker = extend(neomake#utils#MakerFromCommand(
      \ 'echo out-1; sleep 0.1; echo out-22; sleep 0.1; echo out-333'), {
      \ 'buffer_output': 0, 'errorformat': '%m',
      \ 'append_file': 0,
      \ 'postprocess': function('s:postprocess')})

    let jobinfo = neomake#Make(1, [maker])[0]
    NeomakeTestsWaitForFinishedJobs
    AssertNeomakeMessage 'unnamed_maker: processing 1 lines of output.', 3, jobinfo
    if !has('nvim-0.2.0')
      AssertNeomakeMessage 'exit (delayed): unnamed_maker: 0.', 3, jobinfo
      AssertNeomakeMessage "Calling User autocmd NeomakeCountsChanged with context: {'jobinfo': '…', 'reset': 0}."
    endif

    AssertNeomakeMessage "stdout: unnamed_maker: ['out-22', ''].", 3, jobinfo
    AssertNeomakeMessage 'unnamed_maker: processing 1 lines of output.', 3, jobinfo
    AssertNeomakeMessage "Calling User autocmd NeomakeCountsChanged with context: {'jobinfo': '…', 'reset': 0}."

    AssertNeomakeMessage "stdout: unnamed_maker: ['out-333', ''].", 3, jobinfo
    AssertNeomakeMessage 'unnamed_maker: processing 1 lines of output.', 3, jobinfo
    AssertNeomakeMessage "Calling User autocmd NeomakeCountsChanged with context: {'jobinfo': '…', 'reset': 0}."

    if !has('nvim-0.2.0')
      AssertNeomakeMessage 'Trigger delayed exit.', 3, jobinfo
    endif

    AssertEqual map(getloclist(0), 'v:val.text'), ['out-1', 'out-22', 'out-333']
    AssertEqual s:postprocess_count, 3, 'postprocess count should be 3, but is '.s:postprocess_count
    AssertEqual len(g:neomake_test_countschanged), 3
    AssertEqual len(g:neomake_test_jobfinished), 1
    AssertEqual len(g:neomake_test_finished), 1
  endif

Execute (Pending output with restarted job when not in normal/insert mode (loclist)):
  if NeomakeAsyncTestsSetup()
    let g:neomake_test_inc_maker_counter = 0

    new
    file b1
    let jobinfo1 = neomake#Make({'enabled_makers': [g:neomake_test_inc_maker]})[0]
    let make_id = neomake#GetStatus().last_make_id
    norm! V
    NeomakeTestsWaitForFinishedJobs
    AssertNeomakeMessage 'Not processing output for mode "V".', 3
    exe "norm! \<Esc>"
    call neomake#Make(1, [g:neomake_test_inc_maker])

    " Maker is different because of args.
    AssertNeomakeMessageAbsent 'Cancelling already running job ('
      \ .make_id.'.'.jobinfo1.id.') for the same maker.', 2, {'make_id': make_id+1}
    AssertNeomakeMessageAbsent 'Removing already finished job', 3, jobinfo1
    NeomakeTestsWaitForFinishedJobs
    AssertEqual map(getloclist(0), 'v:val.text'),
    \ ['2:0: buf: b1', '2:1: buf: b1']
    doautocmd CursorHold

    AssertEqual map(getloclist(0), 'v:val.text'),
    \ ['2:0: buf: b1', '2:1: buf: b1']

    lolder
    AssertEqual map(getloclist(0), 'v:val.text'),
    \ ['1:0: buf: b1']
    AssertEqual len(g:neomake_test_finished), 2
    AssertEqual len(g:neomake_test_jobfinished), 2
    bwipe
    bwipe b2
  endif

Execute (Pending output with restarted job when not in normal/insert mode (quickfix)):
  if NeomakeAsyncTestsSetup()
    let g:neomake_test_inc_maker_counter = 0

    new
    file b1
    let jobinfo1 = neomake#Make({'file_mode': 0, 'enabled_makers': [g:neomake_test_inc_maker]})[0]
    let make_id = neomake#GetStatus().last_make_id
    norm! V
    NeomakeTestsWaitForFinishedJobs
    AssertNeomakeMessage 'Not processing output for mode "V".', 3
    exe "norm! \<Esc>"
    call neomake#Make(0, [g:neomake_test_inc_maker])

    " Maker is different because of args.
    AssertNeomakeMessageAbsent 'Cancelling already running job ('
      \ .make_id.'.'.jobinfo1.id.') for the same maker.', 2, {'make_id': make_id+1}
    AssertNeomakeMessageAbsent 'Removing already finished job', 3, jobinfo1
    NeomakeTestsWaitForFinishedJobs
    AssertEqual len(g:neomake_test_jobfinished), 2
    AssertEqual len(g:neomake_test_finished), 2

    AssertEqual map(getqflist(), 'v:val.text'),
    \ ['2:0: buf: b1', '2:1: buf: b1']
    doautocmd CursorHold

    AssertEqual map(getqflist(), 'v:val.text'),
    \ ['2:0: buf: b1', '2:1: buf: b1']

    colder
    AssertEqual map(getqflist(), 'v:val.text'),
    \ ['1:0: buf: b1']

    AssertEqual len(g:neomake_test_finished), 2
    AssertEqual len(g:neomake_test_jobfinished), 2
    bwipe
    bwipe b2
  endif

Execute (Second make finishes before first (qflist)):
  let maker1 = NeomakeTestsCommandMaker('maker1', 'sleep .1; echo 1')
  let maker2 = NeomakeTestsCommandMaker('maker2', 'echo 2')
  call neomake#Make(0, [maker1])
  call neomake#Make(0, [maker2])
  NeomakeTestsWaitForFinishedJobs

  if neomake#has_async_support()
    AssertEqual map(getqflist(), 'v:val.text'), ['1']
    colder
  endif
  AssertEqual map(getqflist(), 'v:val.text'), ['2']

Execute (Second make finishes before first (loclist)):
  let maker1 = NeomakeTestsCommandMaker('maker1', 'sleep .1; echo 1')
  let maker2 = NeomakeTestsCommandMaker('maker2', 'echo 2')
  call neomake#Make(1, [maker1])
  call neomake#Make(1, [maker2])
  NeomakeTestsWaitForFinishedJobs

  if neomake#has_async_support()
    AssertEqual map(getloclist(0), 'v:val.text'), ['1']
    lolder
  endif
  AssertEqual map(getloclist(0), 'v:val.text'), ['2']

Execute (Handle finished job that got canceled (#1158)):
  call g:NeomakeSetupAutocmdWrappers()
  norm! V
  CallNeomake 0, [g:success_maker]
  let jobs = neomake#Make(0, [g:success_maker])
  if neomake#has_async_support()
    AssertNeomakeMessage '\mCancelling already running job (\d\+.\d\+) for the same maker.'
    NeomakeTestsWaitForFinishedJobs
    call neomake#CancelJob(jobs[0])
    AssertEqual len(g:neomake_test_jobfinished), 0
  else
    " XXX: should not run in non-async Vim (in this constructed case).
    AssertEqual len(g:neomake_test_jobfinished), 2
  endif

Execute (Job does not get restarted when canceled):
  if NeomakeAsyncTestsSetup()
    let maker = NeomakeTestsCommandMaker('mymaker', 'echo output; sleep .1; echo output2')
    let jobinfo = neomake#Make({'enabled_makers': [maker]})[0]
    NeomakeTestsWaitForMessage "stdout: mymaker: ['output', ''].", 3, jobinfo
    call neomake#CancelJob(jobinfo.id)

    let jobinfo2 = neomake#Make(1, [maker])[0]
    NeomakeTestsWaitForFinishedJobs

    AssertNeomakeMessage "stdout: mymaker: ['output', ''].", 3, jobinfo2
    AssertNeomakeMessage 'exit: job was canceled.', 3, jobinfo, {'ignore_order': 1}

    AssertEqual len(g:neomake_test_finished), 1
    AssertEqual len(g:neomake_test_jobfinished), 1
"     AssertEqual len(g:neomake_test_countschanged), 0
    AssertEqual len(g:neomake_test_countschanged), 1
  endif

Execute (100 lines of output should not get processed one by one):
  " This would be the case when using Vim's 'nl' mode.
  call g:NeomakeSetupAutocmdWrappers()
  let maker = NeomakeTestsCommandMaker('echo_100', 'i=100; while ((i--)); do echo $i; done')
  let maker.buffer_output = 0
  call neomake#Make(0, [maker])
  NeomakeTestsWaitForFinishedJobs
  let c = g:neomake_test_countschanged
  Assert len(c) < 50, 'There were 50+ count changes: '.len(c)
  AssertNeomakeMessage '\v^Skipped \d+ entries without bufnr\.'

Execute (Mixed newlines get handled correctly):
  let maker = {
  \ 'exe': 'printf',
  \ 'args': 'line1\\nline2\\r\\nline3',
  \ 'errorformat': '%m',
  \ }
  call neomake#Make(0, [maker])
  NeomakeTestsWaitForFinishedJobs
  AssertEqual map(getqflist(), 'v:val.text'),
  \ ['line1', 'line2', 'line3']

Execute (Exception in process_output gets logged as error):
  if NeomakeAsyncTestsSetup()
    let maker = {
    \ 'exe': 'printf',
    \ 'args': ['foo'],
    \ 'append_file': 0}
    function! maker.process_output(context) abort
      throw "TEST_ERROR"
    endfunction

    let jobinfo = neomake#Make(1, [maker])[0]

    NeomakeTestsWaitForFinishedJobs
    AssertNeomakeMessage 'unnamed_maker: processing 1 lines of output.'
    AssertNeomakeMessage 'Error during output processing for unnamed_maker: TEST_ERROR.', 0, jobinfo
  endif

Execute (Already running job gets restarted in case of exception):
  if NeomakeAsyncTestsSetup()
    Save g:neomake_test_counter
    let g:neomake_test_counter = 0

    let maker = {
    \ 'exe': 'printf',
    \ 'args': ['foo'],
    \ 'append_file': 0}
    function! maker.process_output(context) abort
      let g:neomake_test_counter += 1
      if g:neomake_test_counter == 1
        throw 'NeomakeTestsException'
      endif
      return []
    endfunction

    let jobinfo = neomake#Make({'enabled_makers': [maker]})[0]
    let make_id = neomake#GetStatus().last_make_id

    AssertThrows NeomakeTestsWaitForFinishedJobs
    AssertEqual g:vader_exception, 'NeomakeTestsException'
    AssertNeomakeMessage 'unnamed_maker: processing 1 lines of output.'

    AssertEqual len(neomake#GetJobs()), 1, 'the job has not been clean because of the exception'

    " Restart, which should work directly.
    call neomake#Make(1, [maker])

    AssertNeomakeMessage printf('Cancelling already running job (%d.%d) for the same maker.',
    \ make_id, jobinfo.id), 2, {'make_id': make_id+1}

    if has('nvim')
      AssertNeomakeMessage 'jobstop failed: Vim(call):E900: Invalid job id.', 2, jobinfo
    else
      try
        AssertNeomakeMessage 'job_stop: job was not running anymore.', 2, jobinfo
      catch
        " Happens at least on Vim 8.0.69.
        if !has('patch-8.0.70')
          throw v:exception.' (might be a flaky test)'
        endif
      endtry
    endif

    AssertNeomakeMessage "Starting async job: ['printf', 'foo']."

    " Needs careful cleanup after exception.
    NeomakeTestsWaitForMessage 'Cleaning jobinfo.'
    NeomakeCancelJobs!
  endif

Execute (process_output: gets delayed for location list):
  let maker = {'exe': 'echo', 'args': 'ignored', 'append_file': 0}
  function! maker.process_output(context)
    return [{
    \ 'bufnr': bufnr('%'),
    \ 'lnum': 23,
    \ 'pattern': '',
    \ 'col': 42,
    \ 'vcol': 0,
    \ 'nr': 4711,
    \ 'text': 'error message',
    \ 'type': 'E',
    \ }]
  endfunction

  new
  let bufnr = bufnr('%')

  call neomake#Make(1, [maker])
  if neomake#has_async_support()
    new
    NeomakeTestsWaitForFinishedJobs
    AssertNeomakeMessage 'Output left to be processed, not cleaning job yet.'
    AssertEqual getloclist(0), []
    bwipe
  endif
  AssertEqual getloclist(0)[0].bufnr, bufnr
  bwipe

Execute (get_list_entries: delayed for location list (but in current context)):
  let maker = {}
  function! maker.get_list_entries(context)
    return [{
    \ 'bufnr': bufnr('%'),
    \ 'lnum': 23,
    \ 'pattern': '',
    \ 'col': 42,
    \ 'vcol': 0,
    \ 'nr': 4711,
    \ 'text': 'error message',
    \ 'type': 'E',
    \ }]
  endfunction

  augroup neomake_tests
    au User NeomakeJobFinished call neomake#utils#DebugMessage('Changing to window 1.')
    au User NeomakeJobFinished 1wincmd w
  augroup END

  let win1_bufnr = bufnr('%')
  new
  let b:neomake_serialize = 1
  let bufnr = bufnr('%')

  call neomake#Make(1, [g:sleep_maker, maker])
  NeomakeTestsWaitForFinishedJobs
  AssertNeomakeMessage 'unnamed_maker: getting entries via get_list_entries.', 2
  AssertNeomakeMessage 'Postponing location list processing.', 3
  AssertEqual getloclist(0), []
  AssertEqual winnr(), 1
  AssertNeomakeMessage 'Skipping cleaning of job info because of queued actions: s:ProcessEntries.', 3
  let valid = has('patch-8.0.0580')
  AssertEqual getloclist(2), [{
  \ 'lnum': 0, 'bufnr': 0, 'col': 0, 'valid': valid, 'vcol': 0, 'nr': -1,
  \ 'type': 'W', 'pattern': '', 'text': 'slept'}]

  2wincmd w
  AssertNeomakeMessage 'action queue: processing for WinEnter (2 items, winnr: 2).'
  AssertNeomakeMessage 'Cleaning jobinfo.'
  AssertNeomakeMessage "Calling User autocmd NeomakeJobFinished with context: {'jobinfo': '…'}.", 2

  AssertEqual winnr(), 1
  AssertEqual map(getloclist(2), '[v:val.bufnr, v:val.text, v:val.type]'), [
  \ [0, 'slept', 'W'],
  \ [win1_bufnr, 'error message', 'E']]
  2wincmd w
  bwipe

Execute (Pending output gets processed in order of jobs (project first)):
  if NeomakeAsyncTestsSetup()
  let maker1 = NeomakeTestsCommandMaker('project_maker', 'sleep .1; echo project_maker')
  let maker2 = NeomakeTestsCommandMaker('file_maker', 'echo file_maker')

  call neomake#Make(0, [maker1])
  call neomake#Make(1, [maker2])
  norm! V

  NeomakeTestsWaitForFinishedJobs
  exe "norm! \<Esc>"
  doautocmd CursorHold
  NeomakeTestsWaitForRemovedJobs
  AssertNeomakeMessage 'Not processing output for mode "V".'
  AssertNeomakeMessage 'Creating quickfix list.'
  AssertNeomakeMessage 'Creating location list.'

  AssertEqual map(getloclist(0), 'v:val.text'), ['file_maker']
  AssertEqual map(getqflist(), 'v:val.text'), ['project_maker']
  endif

Execute (Pending output gets processed in order of jobs (file mode first)):
  if NeomakeAsyncTestsSetup()
  let maker1 = NeomakeTestsCommandMaker('project_maker', 'sleep .1; echo project_maker')
  let maker2 = NeomakeTestsCommandMaker('file_maker', 'echo file_maker')

  call neomake#Make(1, [maker2])
  call neomake#Make(0, [maker1])
  norm! V

  NeomakeTestsWaitForFinishedJobs
  exe "norm! \<Esc>"
  doautocmd CursorHold
  NeomakeTestsWaitForRemovedJobs
  AssertNeomakeMessage 'Not processing output for mode "V".'
  AssertNeomakeMessage 'Creating location list.'
  AssertNeomakeMessage 'Creating quickfix list.'

  AssertEqual map(getloclist(0), 'v:val.text'), ['file_maker']
  AssertEqual map(getqflist(), 'v:val.text'), ['project_maker']
  endif

" Execute ():
"   if NeomakeAsyncTestsSetup()
"     let maker1 = NeomakeTestsCommandMaker('sleep', 'sleep .1')
"     let maker2 = NeomakeTestsCommandMaker('true', 'true')
"     new
"     lgetexpr 'init'
"     file file_sleep_efm
"     call neomake#Make(1, [maker1, maker2])
"     norm! V
"     NeomakeTestsWaitForFinishedJobs
"     AssertEqual map(copy(getloclist(0)), 'v:val.text'), ['init'], 'Location list has not been updated'
"     " with Vim
"     " AssertNeomakeMessage 'exit (delayed): sleep_efm_maker: 0'
" "     AssertNeomakeMessage 'sleep_efm_maker: completed with exit code 0.'
"     AssertEqual mode(), 'V'
"     exe "norm! \<Esc>"
"     AssertEqual mode(), 'n'
"     AssertEqual len(g:neomake_test_countschanged), 0
"     AssertEqual len(g:neomake_test_finished), 0
"     doautocmd CursorHold
"     AssertEqual len(g:neomake_test_countschanged), 1
"     AssertEqual len(g:neomake_test_finished), 1, "b"
"     AssertNeomakeMessage 'sleep_efm_maker: processing 3 lines of output.'
"     AssertEqual map(copy(getloclist(0)), 'v:val.text'), ['error message', 'warning', 'error2']
"     bwipe
"   endif

Execute (get_list_entries job processes entries while in tabline function):
  if NeomakeAsyncTestsSetup()
    Save &tabline

    Save g:entry_maker
    let g:entry_maker = {}
    function! g:entry_maker.get_list_entries(jobinfo) abort
      return get(g:, 'neomake_test_getlistentries', [
      \   {'bufnr': bufnr('%'), 'text': 'error', 'lnum': 1, 'type': 'E'}])
    endfunction

    function! s:NeomakeTestTabline()
      sleep 500m
    endfunction

    new
    set tabline=%!s:NeomakeTestTabline()

    Save g:neomake_test_jobinfo
    function! s:NeomakeTestF(...) abort
      call neomake#Make(1, [g:entry_maker])
"       let g:neomake_test_jobinfo = neomake#GetJob(neomake#Make(1, [g:entry_maker])[0])
    endfunction

    call timer_start(100, function('s:NeomakeTestF'))
    redraw
    NeomakeTestsWaitForFinishedJobs
    AssertEqual len(g:neomake_test_finished), 1
    bwipe
  endif

Execute (action queue handles E48 in process_output):
  let maker = {'exe': 'echo', 'arg': 'output', 'append_file': 0}
  function! maker.process_output(...)
    " causes E48
    sandbox bprevious
  endfunction
  new
  let jobinfo = neomake#Make(1, [maker])
  AssertEqual len(neomake#GetJobs()), 1, 'There is one job.'

  let async = neomake#has_async_support()
  if async
    NeomakeTestsWaitForFinishedJobs
  endif
  AssertNeomakeMessage 'exit: unnamed_maker: 0.'
  AssertNeomakeMessage 'unnamed_maker: processing 1 lines of output.'
  AssertNeomakeMessage 'Error during pcall: Vim(bprevious):E48: Not allowed in sandbox:   sandbox bprevious.', 3
  AssertNeomakeMessage 'Queueing action: s:ProcessJobOutput for Timer.'
  if has('timers')
    AssertNeomakeMessage 'Retrying Timer event in 10ms.'
  else
    AssertNeomakeMessage 'Retrying Timer event on CursorHold(I).'
  endif
  if async
    AssertNeomakeMessage 'unnamed_maker: completed with exit code 0.'
  endif
  AssertNeomakeMessage 'Skipping cleaning of job info because of queued actions: s:ProcessJobOutput.'
  AssertNeomakeMessage 'Queueing action: s:CleanJobinfo for WinEnter.'

  bwipe
  AssertNeomakeMessage 'action queue: processing for WinEnter (1 items, winnr: 1).'
  if async
    AssertNeomakeMessage 'action queue: processing for Timer (1 items, winnr: 1).'
    AssertNeomakeMessage 'action queue: calling s:ProcessJobOutput.'
    AssertNeomakeMessage 'Postponing location list processing.'
    AssertNeomakeMessage 'Queueing action: s:ProcessJobOutput for WinEnter.'
    AssertNeomakeMessage 'action queue: processed 0 items.'
  endif
  AssertNeomakeMessage 'action queue: calling s:CleanJobinfo.'
  AssertNeomakeMessage 'Skipping cleaning of job info because of queued actions: s:ProcessJobOutput.'
  AssertNeomakeMessage 'Queueing action: s:CleanJobinfo for WinEnter.'
  AssertNeomakeMessage 'action queue: processed 0 items.'

  call neomake#CancelAllMakes()
  AssertNeomakeMessage 'Removed 2 action queue entries.', 3, jobinfo
  if async
    AssertNeomakeMessage 'Removing already finished job.', 3, jobinfo
  endif
  AssertNeomakeMessage 'Cleaning jobinfo.', 3, jobinfo

Execute (job finishes while in tabline function):
  if neomake#has_async_support()  " use manual setup without autocmds to work around bug in vim8069
    Save &tabline, g:neomake_test_flagfile

    let g:neomake_test_flagfile = tempname()

    function! s:NeomakeTestTabline()
      call writefile(['1'], g:neomake_test_flagfile)
      while 1
        if !filereadable(g:neomake_test_flagfile)
          break
        endif
        sleep 1m
      endwhile
      NeomakeTestsWaitForMessage 'Error during pcall: Vim(laddexpr):E523: Not allowed here:                 laddexpr a:lines.', 3
      AssertNeomakeMessage '\v\(in function .*\.\.\<SNR\>\d+_NeomakeTestTabline\[\d+\]\.\..*\)', 3
      call neomake#utils#DebugMessage('tabline_end.')
    endfunction

    new
    set tabline=%!s:NeomakeTestTabline()
    let maker1 = NeomakeTestsCommandMaker('sleep', printf(
    \ 'while ! [ -e %s ]; do sleep 0.01; done; echo finished_in_tabline; rm %s',
    \ fnameescape(g:neomake_test_flagfile), fnameescape(g:neomake_test_flagfile)))
    let jobinfo = neomake#GetJob(neomake#Make(1, [maker1])[0])
    redraw
    NeomakeTestsWaitForFinishedJobs

    AssertNeomakeMessage 'Skipping cleaning of job info because of queued actions: s:ProcessJobOutput.'
    AssertNeomakeMessage 'Queueing action: s:CleanJobinfo for WinEnter.'
    AssertNeomakeMessage 'tabline_end.', 3

    doautocmd WinEnter
    AssertEqual map(getloclist(0), 'v:val.text'), ['finished_in_tabline']
    bwipe
    Assert exists('#neomake_statusline'), 'statusline augroup was created'
    Assert !exists('#neomake_statusline#ColorScheme'), 'ColorScheme was not hooked into'
  else
    NeomakeTestsSkip 'no async support.'
  endif

Execute (get_list_entries job processes entries while in tabline function):
  if NeomakeAsyncTestsSetup()
    Save &tabline

    Save g:entry_maker
    let g:entry_maker = {}
    function! g:entry_maker.get_list_entries(jobinfo) abort
      return get(g:, 'neomake_test_getlistentries', [
      \   {'bufnr': bufnr('%'), 'text': 'error', 'lnum': 1, 'type': 'E'}])
    endfunction

    let g:neomake_test_tabline = 0
    function! s:NeomakeTestTabline()
      AssertEqual len(g:neomake_test_finished), 0
      let g:neomake_test_tabline = 1
      sleep 10m
      AssertEqual len(g:neomake_test_finished), 1
    endfunction

    new
    set tabline=%!s:NeomakeTestTabline()

    Save g:neomake_test_jobinfo
    function! s:NeomakeTestF(...) abort
      call neomake#Make(1, [g:entry_maker])
    endfunction

    call timer_start(0, function('s:NeomakeTestF'))
    redraw
    NeomakeTestsWaitForFinishedJobs
    AssertEqual g:neomake_test_tabline, 1
    AssertEqual len(g:neomake_test_finished), 1
    bwipe
  endif

Execute (make info gets cleaned when last job fails to start):
  call g:NeomakeSetupAutocmdWrappers()
  new
  let b:neomake_serialize = 1
  let b:neomake_tempfile_enabled = 0
  set ft=neomake_tests
  RunNeomake echo_maker true
  bwipe
  AssertEqual len(g:neomake_test_finished), 1
  AssertEqual len(g:neomake_test_jobfinished), 1
  AssertNeomakeMessage 'no file name.', 0

Execute (neomake#Make ignores calls during autocommands):
  Save g:neomake_open_list
  let g:neomake_open_list = 2

  Save g:neomake_test_enabledmakers
  let g:neomake_test_enabledmakers = ['process_output_error']

  new
  setf neomake_tests

  call g:NeomakeSetupAutocmdWrappers()
  augroup neomake_tests
    autocmd WinEnter * call neomake#utils#DebugMessage('WinEnter: '.winnr().': '.&ft.'.')
    autocmd WinEnter * Neomake
  augroup END

  let win1 = winnr()
  let job1 = neomake#Make({})
  NeomakeTestsWaitForFinishedJobs

  AssertNeomakeMessage 'process_output_error: processing 1 lines of output.', 3
  AssertNeomakeMessage 'Handling location list: executing lwindow.', 3
  AssertNeomakeMessage 'Ignoring Make through autocommand due to s:ignore_automake_events=1.', 3, {'winnr': 3}
  AssertNeomakeMessage 'Ignoring Make through autocommand due to s:ignore_automake_events=1.', 3, {'winnr': 1}
  AssertNeomakeMessage 'Ignoring Make through autocommand due to s:ignore_automake_events=1.', 3, {'winnr': 2}

  AssertEqual len(g:neomake_test_finished), 1
  AssertEqual len(g:neomake_test_jobfinished), 1

  lclose
  bwipe
